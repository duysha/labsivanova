#include <iostream>
#include <vector>
#include <string>

enum class Type {
 Art, Tech
};

class Book
{
public:
 Book(const std::string& avtor, const std::string& title, Type bookType) :
  _avtor(avtor), _title(title), _bookType(bookType)
 {}
 Type GetType() const
 {
  return _bookType;
 }

private:
 const std::string _avtor;
 const std::string _title;
 const Type _bookType;
};

class Library
{

public:
 bool addbook(const std::string& avtor, const std::string& title, Type bookType)
 {
  if (avtor.empty() || title.empty()) {

   std::cout << "The data is not correct" << std::endl;
   return false;
  }
  else {
   book.emplace_back(title, avtor, bookType);
   return true;
  }
 }
 void PrintSwitch() {
  int ArtCount = 0;
  int TechCount = 0;
  for (Book i : book) {
   switch (i.GetType())
   {
   case Type::Art:
    ++ArtCount;
    break;
   default:
    ++TechCount;
    break;
   }
  }
  std::cout << "Art: " << ArtCount << std::endl;
  std::cout << "Tech: " << TechCount << std::endl;
 }
 void PrintForeach() {
  int ArtCount = 0;
  int TechCount = 0;
  for (Book i : book)
  {
   if (i.GetType() == Type::Art)
   {
    ++ArtCount;
   }
   else if (i.GetType() == Type::Tech)
   {
    ++TechCount;
   }
  }
  std::cout << "Art: " << ArtCount << std::endl;
  std::cout << "Tech: " << TechCount << std::endl;
 }
private:
 std::vector <Book> book;
};


int main()
{
 Library library;

 library.addbook("Pushkin", "Ruslan and Ludmila", Type::Art);
 library.addbook("Klaus Iglberger", "C++ Software Design", Type::Tech);
 library.addbook("Rainer Grimm", "C++ Core Guidelines", Type::Tech);

 library.PrintSwitch();

 std::cout << "---------------------" << std::endl;

 library.PrintForeach();

 return 0;
}
Задание 1
#define _CRTDBG_MAP_ALLOC
#include <crtdbg.h>
#include <iostream>
#include <fstream>
#include <vector>
#include <string>

struct Leaks {
 ~Leaks() { _CrtDumpMemoryLeaks(); }
}_l;

class Car {
private:
 const std::string _model;
public:
 Car(const std::string& model) : _model(model) {}

 virtual ~Car() {}

 const std::string& getModel()
 {
  return _model;
 }
};

class Mercedes : public Car {
public:
 Mercedes(const std::string& model) : Car(model) {}
 virtual ~Mercedes() {
  std::cout << "Mercedes " << " " << getModel() << std::endl;
 }
};

class Honda :public Car {
public:
 Honda(const std::string& model) : Car(model) {}
 virtual ~Honda() {
  std::cout << "Honda" << " " << getModel() << std::endl;
 };
};

class BMW :public Car {
public:
 BMW(const std::string& model) : Car(model) {}
 virtual ~BMW() {
  std::cout << "BMW" << " " << getModel() << std::endl;
 };
};

int main() {

 std::string path = "cars.txt";
 std::ifstream file;
 file.open(path);
 if (!file.is_open()) {
  std::cout << "Error" << std::endl;
 }
 else
 {
  std::cout << "Open!" << std::endl;
 }
 std::vector <Car*> cars;
 std::string _brand;
 std::string _model;

 while (file >> _brand >> _model) {

  if (_brand == "Mercedes")
  {
   cars.push_back(new Mercedes(_model));
  }
  else if (_brand == "BMW")
  {
   cars.push_back(new BMW(_model));
  }
  else if (_brand == "Honda") {
   cars.push_back(new Honda(_model));
  }
 }

 file.close();

 for (auto Car : cars)
 {
  delete Car;
 }

 return 0;
}
